package My::MiniCPAN;

use 5.008008;
use strict;
use warnings;

use File::Spec;
use File::HomeDir;
use Data::Dumper qw/Dumper/;
use FindBin qw/$Bin/;
use lib File::Spec->catfile($Bin, '..');

use Moose;
use namespace::autoclean;
use Moose::Util::TypeConstraints;
use MooseX::Traits::SetScalarByRef;
use curry;

use threads;
use threads::shared;
use Thread::Queue;

use CPAN::Mini;
use DBI;
use DBD::SQLite;
use My::MiniCPAN::Schema;
use Color::Rgb;
use File::ShareDir qw/dist_file/;

use Tk 804;
use Tk::Animation;
use Tk::Dialog;
use Tk::Menu;
use Tk::Text;
use Tk::HList;
use Tk::Treeplus;
use Tk::Image;
use Tk::Labelframe;
use Tk::Radiobutton;
use Tk::StatusBar;
use Tk::ToolBar;
use Tk::LabEntry;
use Tk::ROText;
use Tk::PNG;
use Tk::Photo;
use Tk::Treeplus;

# -- PerlApp explicit module mentionings
use B::Hooks::EndOfScope::XS;
use Variable::Magic;
use SQL::Abstract;
# -- /PerlApp

our $VERSION = '0.01';

# use coerce to glue Moose's attributes on Tk's textvariables
subtype 'TkRef' => as 'ScalarRef';
coerce 'TkRef', from 'Str', via { my $r = $_; return \$r };


=head1 NAME

My::MiniCPAN - GUI to manage, create, or update a local CPAN mirror using CPAN::Mini

=head1 SYNOPSIS

  use strict;
  use warnings;
  use My::MiniCPAN;
  
  my $app = My::MiniCPAN->new();
  $app->run; # start the GUI
  exit(0);

=head1 DESCRIPTION

This package is a GUI front-end for L<CPAN::Mini>.
It allows to manage and to execute CPAN::Mini through a GUI.

=head1 ATTRIBUTES

=head2 minicpan_execution_request_flag

This is a flag indicating that the user requested a minicpan execution.

=cut

has 'minicpan_execution_request_flag' => (is => 'rw', isa => 'ScalarRef[Int]', default => sub{
    my $minicpan_execution_request_flag: shared = 0;
    return \$minicpan_execution_request_flag;
});


=head2 minicpan_execution_finished_flag

This is a flag indicating that the minicpan operation has been finished.

=cut

has 'minicpan_execution_finished_flag' => (is => 'rw', isa => 'ScalarRef[Int]', default => sub{
    my $minicpan_execution_finished_flag: shared = 0;
    return \$minicpan_execution_finished_flag;
});


=head2 minicpan_worker_thread

Thread that will create the local CPAN mirror if signalled by L<My::MiniCPAN/minicpan_execution_request_flag>.

=cut

has 'minicpan_worker_thread' => (is => 'ro', isa => 'Any', default => sub{
    my $self = shift;
    my $minicpan_thr = threads->create(sub{ $self->execute_cpanmini_worker(); });
    return $minicpan_thr;
});


=head2 minicpan_messages_queue

L<Thread::Queue> for output generated by CPAN::Mini.
Will eventually be reflected in the GUI.

=cut

has 'p_queue' => (is => 'ro', isa => 'Thread::Queue', default => sub{ return Thread::Queue->new(); });


=head2 config_db

Path to the L<DBD::SQLite> database file containing all settings for L<CPAN::Mini>.

=cut

has 'config_db' => (is => 'rw', isa => 'Str', default => sub{
    my $default_path = File::Spec->catfile(
        File::HomeDir->my_data,
        '.minicpan', 'my-minicpan-config.sqlite',
    );
    return $default_path;
});


=head2 schema

Accessor for the application's database schemata.

=cut

has 'schema' => (is => 'ro', isa => 'DBIx::Class::Schema', lazy => 1, default => sub{
    my $self = shift;
    
    my $database = $self->config_db;
    my $driver   = "SQLite";
    my $dsn = "DBI:$driver:dbname=$database";
    my $userid = '';
    my $password = '';
    my %dbi_params = ();
    
    my $schema = My::MiniCPAN::Schema->connect($dsn, $userid, $password, \%dbi_params);
    
    return $schema;
});


=head2 mw

The L<Tk::MainWindow> object for the GUI.

=cut

has 'mw' => (is => 'ro', isa => 'Tk::MainWindow', default => sub{
    my $mw = Tk::MainWindow->new(
        -background  => 'ghostwhite',
        -borderwidth => 1,
        -relief      => 'groove',
        -width       => 500,
        -height      => 500,
        -title       => "MiniCPAN v$VERSION - Configuration and Maintenance",
    );
    return $mw;
});


=head2 cpanmini_execution_animation

Animation that will be played during the creation of the local CPAN mirror.

=cut

has 'cpanmini_execution_animation' => (is => 'ro', isa => 'Tk::Animation', lazy => 1, default => sub{
    my $self = shift;
    
    my @images = qw/system-run-5.png system-run-5_15deg.png/;
    
    my $animate   = $self->mw->Animation;
    
    foreach my $filename (@images) {
        my $path = File::ShareDir::dist_file('My-MiniCPAN', '256x256/' . $filename);
        $animate->add_frame( $self->mw->Photo( -file => $path ) );
    }
    $animate->set_image(0);
    
    # -- clear transparent background while drawing
    $animate->set_disposal_method( 1 );
    
    return $animate;
});


=head2 rgb

Utility to convert RGB valued to HEX values required by Tk.
I'm simply to lazy to always look up the HEX values.

=cut

has 'rgb' => (is => 'ro', isa => 'Color::Rgb', default => sub{
    my $rgb = Color::Rgb->new(rgb_txt => File::ShareDir::dist_file('My-MiniCPAN', 'rgb.txt'));
    return $rgb;
});


=head2 panedwindow

I'm not using a L<Tk::Notebook> because it is way to ugly.
Instead, the GUI uses a L<Tk::PanedWindow> where the navigation
is on the left side and the content is located on the right side.
The Panedwindow is used so that a user can resize the areas.

=cut

has 'panedwindow' => (is => 'rw', isa => 'Any',);


=head2 module_filter_hlist

L<Tk::Treeplus> containing the module and path filters for CPAN::Mini.

=cut

has 'module_filter_hlist' => (is => 'rw', isa => 'Any');


=head2 workspace_area

Frame containing the CPAN::Mini workspace.
Here, a user can start the creation of the local CPAN mirror.

=cut

has 'workspace_area' => (is => 'rw', isa => 'Any',);


=head2 mirror_definition_area

Frame where the user can define the source CPAN mirror and the target location on disk.

=cut

has 'mirror_definition_area' => (is => 'rw', isa => 'Any');


=head2 mirror_options_area

Frame containing almost all CPAN::Mini options.

=cut

has 'mirror_options_area' => (is => 'rw', isa => 'Any');


=head2 module_filter_area

Frame listing all filters applied to the local CPAN mirror.
Includes a form to add/edit/delete filters.

=cut

has 'module_filter_area' => (is => 'rw', isa => 'Any');


=head2 workspace_menu_entry

The menu button for accessing the workspace area.

=cut

has 'workspace_menu_entry' => (is => 'rw', isa => 'Any',);


=head2 mirror_definition_menu_entry

The menu button for accessing the mirror definition area.

=cut

has 'mirror_definition_menu_entry' => (is => 'rw', isa => 'Any',);


=head2 mirror_options_menu_entry

The menu button for accessing the mirror options area.

=cut

has 'mirror_options_menu_entry' => (is => 'rw', isa => 'Any');


=head2 module_filter_menu_entry

The menu button for accessing the filter definition area.

=cut

has 'module_filter_menu_entry' => (is => 'rw', isa => 'Any',);


# CPAN::Mini options. Maybe manage them in some other way, e.g. by a class or a hash.
# Same holds for all other repetive things like menu buttons and contant frames.

has _cpan_mirror_remote => (
    traits   => [ 'MooseX::Traits::SetScalarByRef' ],
    isa      => 'TkRef',
    init_arg => 'cpan_mirror_remote',
    default  => 'http://cpan.metacpan.org/',
    handles  => 1,
);

has _cpan_mirror_local => (
    traits   => [ 'MooseX::Traits::SetScalarByRef' ],
    isa      => 'TkRef',
    init_arg => 'cpan_mirror_local',
    default  => sub{
        my $default_path = File::Spec->catdir(
            File::HomeDir->my_data,
            '.minicpan', 'my-mirror',
        );
        return $default_path;
    },
    handles  => 1,
);

has _option_dirmode => (
    traits   => [ 'MooseX::Traits::SetScalarByRef' ],
    isa      => 'TkRef',
    init_arg => 'option_dirmode',
    default  => '0711',
    handles  => 1,
);

has _option_exact_mirror => (
    traits   => [ 'MooseX::Traits::SetScalarByRef' ],
    isa      => 'TkRef',
    init_arg => 'option_exact_mirror',
    default  => 0,
    handles  => 1,
);

has _option_ignore_source_control => (
    traits   => [ 'MooseX::Traits::SetScalarByRef' ],
    isa      => 'TkRef',
    init_arg => 'option_ignore_source_control',
    default  => 1,
    handles  => 1,
);

has _option_force => (
    traits   => [ 'MooseX::Traits::SetScalarByRef' ],
    isa      => 'TkRef',
    init_arg => 'option_force',
    default  => 0,
    handles  => 1,
);

has _option_skip_perl => (
    traits   => [ 'MooseX::Traits::SetScalarByRef' ],
    isa      => 'TkRef',
    init_arg => 'option_skip_perl',
    default  => 1,
    handles  => 1,
);

has _option_log_level => (
    traits   => [ 'MooseX::Traits::SetScalarByRef' ],
    isa      => 'TkRef',
    init_arg => 'option_log_level',
    default  => 'fatal',
    handles  => 1,
);

has _option_errors => (
    traits   => [ 'MooseX::Traits::SetScalarByRef' ],
    isa      => 'TkRef',
    init_arg => 'option_errors',
    default  => 1,
    handles  => 1,
);

has _option_skip_cleanup => (
    traits   => [ 'MooseX::Traits::SetScalarByRef' ],
    isa      => 'TkRef',
    init_arg => 'option_skip_cleanup',
    default  => 0,
    handles  => 1,
);

has _option_offline => (
    traits   => [ 'MooseX::Traits::SetScalarByRef' ],
    isa      => 'TkRef',
    init_arg => 'option_offline',
    default  => 0,
    handles  => 1,
);

has _option_no_conn_cache => (
    traits   => [ 'MooseX::Traits::SetScalarByRef' ],
    isa      => 'TkRef',
    init_arg => 'option_no_conn_cache',
    default  => 0,
    handles  => 1,
);


# Form fields for the filter definition form.

has _filter_add_edit_form_type => (
    traits   => [ 'MooseX::Traits::SetScalarByRef' ],
    isa      => 'TkRef',
    init_arg => 'filter_add_edit_form_type',
    default  => 1,
    handles  => 1,
);

has _filter_add_edit_form_pattern => (
    traits   => [ 'MooseX::Traits::SetScalarByRef' ],
    isa      => 'TkRef',
    init_arg => 'filter_add_edit_form_pattern',
    default  => '',
    handles  => 1,
);

has _filter_add_edit_form_comment => (
    traits   => [ 'MooseX::Traits::SetScalarByRef' ],
    isa      => 'TkRef',
    init_arg => 'filter_add_edit_form_comment',
    default  => '',
    handles  => 1,
);


=head1 METHODS

=head2 BUILD(%args)

Builds the GUI.

=cut

sub BUILD {
    my $self = shift;
    
    my $mw = $self->mw;
    $mw->geometry('800x450');
    my $sb = $mw->StatusBar();
    
    my $paned = $mw->Panedwindow(
        -bg => 'white',
        -orient => 'h',
    )->pack(-fill => 'both', -expand => 1,);
    $self->panedwindow($paned);
    
    my $navigation = $paned->Frame(-bg => 'white', -width => 210);
    
    # ---------------------------------------------------------------------
    # -- define navigation widgets
    my $workspace_menu_entry = $navigation->Button(
        -text => 'Workspace',
        -bg => $self->_rgb2hex(231,231,231),
        -border => 1,
        -relief => 'flat',
        -command => sub{
            # TODO: check for unsaved changes
            $self->show_workspace();
        },
    )->pack(-fill => 'x');
    $self->workspace_menu_entry($workspace_menu_entry);
    
    my $mirror_definition_btn = $navigation->Button(
        -text => 'CPAN Mirror',
        -bg => $self->_rgb2hex(231,231,231),
        -border => 1,
        -relief => 'flat',
        -command => sub{
            # TODO: check for unsaved changes
            $self->show_mirror_definition();
        },
    )->pack(-fill => 'x');
    $self->mirror_definition_menu_entry($mirror_definition_btn);
    
    my $mirror_options_btn = $navigation->Button(
        -text => 'Mirror Options',
        -bg => 'white',
        -border => 1,
        -relief => 'flat',
        -command => sub{
            # TODO: check for unsaved changes
            $self->show_mirror_options();
        },
    )->pack(-fill => 'x');
    $self->mirror_options_menu_entry($mirror_options_btn);
    
    my $module_filter_btn = $navigation->Button(
        -text => 'Module Filter',
        -bg => 'white',
        -border => 1,
        -relief => 'flat',
        -command => sub{
            # TODO: check for unsaved changes
            $self->show_module_filter();
        },
    )->pack(-fill => 'x');
    $self->module_filter_menu_entry($module_filter_btn);
    
    # ---------------------------------------------------------------------
    # -- define content spaces
    
    # -- Workspace
    my $workspace_frame = $paned->Frame(-bg => 'white',);
    $self->workspace_area($workspace_frame);
    $self->_build_workspace_area($workspace_frame);
    
    # -- CPAN mirror definition
    my $mirror_definition_frame = $paned->Frame(-bg => 'white',);
    $self->mirror_definition_area($mirror_definition_frame);
    $self->_build_mirror_definition_area($mirror_definition_frame);    
    
    
    # -- Mirror options
    my $mirror_options_frame = $paned->Frame(-bg => 'white',);
    $self->mirror_options_area($mirror_options_frame);
    $self->_build_mirror_options_area($mirror_options_frame);
    
    
    # -- Module filters
    my $module_filter_outer_frame = $paned->Frame(-bg => 'white',);
    $self->module_filter_area($module_filter_outer_frame);
    $self->_build_module_filter_area($module_filter_outer_frame);

    # define what the pane shows first
    $paned->add($navigation, -width => 210,);
    $paned->add($mirror_definition_frame, );
    
    $mw->update;
    
    return;
} # /BUILD




=head2 run()

Starts the GUI application.

=cut

sub run {
    my $self = shift;
    my $mw = $self->mw;
    
    # when starting the application, show the following pane:
    $self->show_workspace;
    
    # we could start in any other area, too:
    #$self->show_mirror_definition;
    #$self->show_mirror_options;
    #$self->show_module_filter;
    
    # start the GUI's event loop
    $mw->MainLoop;
    
    return;
} # /run




=head2 execute_cpanmini_worker()

This code creates a CPAN mirror using CPAN::Mini.
It's the contant of the worker thread.
So basically, it's a loop waiting to be signalled in order to start work.

TODO: handle this "Perl exited with active threads" message.

=cut

sub execute_cpanmini_worker {
    my $self = shift;
    
	while (1) {
		sleep 2;
		if ( ${$self->minicpan_execution_request_flag} == 1 ) {
			#print "begin child_request\n";
			
            # load the values from config DB
            my @mirror_options = (qw/local remote dirmode exact_mirror ignore_source_control
                                  force skip_perl log_level errors skip_cleanup
                                  offline no_conn_cache /);
            
            my %mirror_options = (
                module_filters => [],
                path_filters => [],
            );
            
            # fill path filter and module filter from DB
            my $filter_rs = $self->schema->resultset('ModuleFilter')->search(
                undef,
                {
                    prefetch => 'filter_type',
                }
            );
            while ( my $filter = $filter_rs->next ) {
                if ( $filter->filter_type->type eq 'path filter' ) {
                    my $pattern = $filter->pattern;
                    push @{$mirror_options{path_filters}}, qr/$pattern/;
                }elsif( $filter->filter_type->type eq 'module filter' ) {
                    my $pattern = $filter->pattern;
                    push @{$mirror_options{module_filters}}, qr/$pattern/;
                }else{
                    warn "Skipping filter with ID " . $filter->id . " - unknown filter type " . $filter->filter_type->type;
                }
            }
            
            my $options_rs = $self->schema->resultset('Option')->search({name => {'-in' => \@mirror_options}});
            while ( my $option = $options_rs->next ) {
                my $option_name = 'option_' . $option->name;
                $mirror_options{$option->name} = $option->value;
            }
            
            print Dumper \%mirror_options;
            CPAN::Mini->update_mirror(%mirror_options);
            #print ">>>>>>>> done\n";
            
			${$self->minicpan_execution_finished_flag} = 1;
		} else {
			print "waiting for child_request\n";
		}
	}    
    
    return;
} # /execute_cpanmini_worker




=head2 _reset_content_area()

Removes anything from the content area (mirror definition / options / module filters).
It is not known which content is currently shown, so all content areas are 'forgotten'.

=cut

sub _reset_content_area {
    my $self = shift;
    
    # remove the content area = remove all areas
    $self->panedwindow->forget(
        $self->workspace_area,
        $self->mirror_definition_area,
        $self->mirror_options_area,
        $self->module_filter_area,
    );
    
    # reset the menu entry highlightning
    $self->workspace_menu_entry->configure(-bg => 'white');
    $self->mirror_definition_menu_entry->configure(-bg => 'white');
    $self->mirror_options_menu_entry->configure(-bg => 'white');
    $self->module_filter_menu_entry->configure(-bg => 'white');
    
    return;
} # /_reset_content_area




=head2 show_workspace()

Shows the area where the user actually can create a CPAN mirror by clicking a button.

=cut

sub show_workspace {
    my $self = shift;
    
    # forget the current content frame
    $self->_reset_content_area();

    # highlight corresponding menu entry
    $self->workspace_menu_entry->configure(-bg => $self->_rgb2hex(231,231,231));
    
    # add the new frame to the pane
    $self->panedwindow->add($self->workspace_area);
    
    return $self;
} # /show_workspace




=head2 show_mirror_definition()

Shows the dialog for selecting the CPAN mirror source and location on disk.

=cut

sub show_mirror_definition {
    my $self = shift;
    
    # forget the current content frame
    $self->_reset_content_area();

    # highlight corresponding menu entry
    $self->mirror_definition_menu_entry->configure(-bg => $self->_rgb2hex(231,231,231));
    
    # add the new frame to the pane
    $self->panedwindow->add($self->mirror_definition_area);
    
    # load the values from config DB
    $self->cpan_mirror_remote($self->read_option('remote'));
    
    my $local = $self->read_option('local');
    if ( $local eq '' ) {
        # set local to default (that is, the current default value of cpan_mirror_local)
        # we do this if the local path is not defined in the database
        # this is the case in the very first startup
        # XXX: could be used if the path does not exist anymore
        $self->write_option('local', ${$self->cpan_mirror_local});
    }else{
        $self->cpan_mirror_local($local);
    }
    
    return $self;
} # /show_mirror_definition




=head2 show_mirror_options()

Shows the minicpan options.

=cut

sub show_mirror_options {
    my $self = shift;
    
    # forget the current content frame
    $self->_reset_content_area();
    
    # highlight corresponding menu entry
    $self->mirror_options_menu_entry->configure(-bg => $self->_rgb2hex(231,231,231));
    
    # add the new frame to the pane
    $self->panedwindow->add($self->mirror_options_area);
    
    # load the values from config DB
    # some checking code was added to be able to notice that something has been forgotten.
    my @mirror_options = (qw/ dirmode exact_mirror ignore_source_control
                          force skip_perl log_level errors skip_cleanup
                          offline no_conn_cache /);
    my %mirror_options = map{$_ => 1} @mirror_options;
    
    my $rs = $self->schema->resultset('Option')->search({name => {'-in' => \@mirror_options}});
    while ( my $option = $rs->next ) {
        die("Unknown option " . $option->name) unless exists $mirror_options{$option->name}; # die hard
        my $option_name = 'option_' . $option->name;
        $self->$option_name($option->value);
        delete $mirror_options{$option->name};
    }
    
    die("Not all options have been read from the database. Missing: " . keys(%mirror_options)) if %mirror_options;
    
    return $self;
} # /show_mirror_options





=head2 show_module_filter()

Shows the filter settings for minicpan.

=cut

sub show_module_filter {
    my $self = shift;
    
    # forget the current content frame
    $self->_reset_content_area();
    
    # highlight corresponding menu entry
    $self->module_filter_menu_entry->configure(-bg => $self->_rgb2hex(231,231,231));
    
    # add the new frame to the pane
    $self->panedwindow->add($self->module_filter_area);
    
    return $self;
} # /show_module_filter




=head2 read_option( $option_name )

Reads the options database and returns the value for C<$option_name>.

TODO: error handling

=cut

sub read_option {
    my $self = shift;
    my $option_name = shift // die('Missing option name');
    
    my $schema = $self->schema;
    #$schema->storage->debug(1);
    my $rs = $schema->resultset('Option')->search({name => $option_name})->first();
    
    #$schema->storage->debug(0);
    #print Dumper $rs;
    #return 'test';
    
    return $rs->value;
} # /read_option




=head2 write_option( $option_name, $option_value )

Writes the options database. Sets C<$option_name> to C<$option_value>.

TODO: error handling

=cut

sub write_option {
    my $self = shift;
    my $option_name = shift // die('Missing option name');
    my $option_value = shift // die('Missing new option value');
    
    my $schema = $self->schema;
    
    #$schema->storage->debug(1);
    my $rs = $schema->resultset('Option')->search({name => $option_name})->first->update({ value => $option_value });
    #$schema->storage->debug(0);
    
    # when debugging does not work...
    #my $rs = $schema->resultset('Option')->search({name => $option_name})->first();
    #
    #my $dbh = $schema->storage->dbh;
    #my $sth = $dbh->prepare('UPDATE option SET value = ? WHERE id = ?');
    #$sth->execute($option_value, $rs->id);
    #$sth->finish;
    
    return $self;
} # /write_option




=head2 _build_bool_option( %args )

Utility method for building the GUI part for a boolean option.
Returns a Frame containing all the widgets.

Consists of:

=over

=item * a Checkbutton bound to a variable reference,

=item * a Label with the option's name,

=item * an optional Label with some descriptive text,

=item * and a Frame packing it all together nicely.

=back

Provide the following args:

    my %expected_args = (
        parent => 'parent widget, e.g. Tk::Frame',
        varaible => 'scalar referece or TkRef',
        option_name => 'name of the option',
        text => undef, # optional, explanatory text
    );

TODO: yes, it's nearly a template for a Moose class. Go for it!

=cut

sub _build_bool_option {
    my $self = shift;
    my %provided_args = @_;
    my %expected_args = (
        parent => 'parent widget, e.g. Tk::Frame',
        varaible => 'scalar referece or TkRef',
        option_name => 'name of the option',
        text => undef, # optional, explanatory text
    );
    my %args = %provided_args;
    
    # TODO: arg checking
    
    my $opt_exact_mirror = $args{parent}->Frame(-bg => 'white');
    $opt_exact_mirror->gridColumnconfigure(1, -weight => 1);
    $opt_exact_mirror->gridRowconfigure(2, -weight => 1);
    $opt_exact_mirror->Checkbutton(
        -onvalue => 1,
        -offvalue => 0,
        -variable => $args{variable},
        -justify => 'left',
        -bg => 'white',
    )->grid(-row => 0, -column => 0, -sticky => 'w');
    
    $opt_exact_mirror->Label(
        -text => $args{option_name},
        -bg => 'white',
    )->grid(-row => 0, -column => 1, -sticky => 'w',);
    
    if ( $args{text} ) {
        $opt_exact_mirror->Label(
            -text => $args{text},
            -justify => 'left',
            -bg => 'white',
        )->grid(-row => 1, -column => 1, -sticky => 'w',);
    }
    
    return $opt_exact_mirror;
} # /_build_bool_option




=head2 _build_add_edit_filter_form( $parent )

Create a frame containing a form to to add / edit a module filter.

=cut

sub _build_add_edit_filter_form {
    my $self = shift;
    my $parent = shift or die('Missing parent widget');
        
    my $filter_definition_frame = $parent->Labelframe(
        -bg => 'white',
        -text => 'Add / edit filter',
    );
    
    $filter_definition_frame->Label(
        -text => 'Filter Type',
        -bg => 'white',
    )->grid(-row => 0, -column => 0);
    $filter_definition_frame->Label(
        -text => 'Pattern',
        -bg => 'white',
    )->grid(-row => 0, -column => 1);
    $filter_definition_frame->Label(
        -text => 'Comment',
        -bg => 'white',
    )->grid(-row => 0, -column => 2);
    
    $filter_definition_frame->Entry(
        -bg => 'white',
        -textvariable => $self->filter_add_edit_form_pattern,
    )->grid(-row => 1, -column => 1, -sticky => 'we');
    
    $filter_definition_frame->Entry(
        -bg => 'white',
        -textvariable => $self->filter_add_edit_form_comment,
    )->grid(-row => 1, -column => 2, -sticky => 'we', -padx => 2);
    
    $filter_definition_frame->gridColumnconfigure(1, -weight => 3);
    $filter_definition_frame->gridColumnconfigure(2, -weight => 1);
    
    my $radio1 = $filter_definition_frame->Radiobutton(
        -text => 'Path filter',
        -value => 1,
        -variable => $self->filter_add_edit_form_type,
        -bg => 'white',
    )->grid(-row => 1, -column => 0);
    
    my $radio2 = $filter_definition_frame->Radiobutton(
        -text => 'Module filter',
        -value => 2,
        -variable => $self->filter_add_edit_form_type,
        -bg => 'white',
    )->grid(-row => 2, -column => 0);
    
    my $module_filters_table_action_frame = $filter_definition_frame->Frame(
        -bg => 'white',
    )->grid(-row => 3, -column => 0, -columnspan => 3, -sticky => 'we');

    # -- clear form
    $module_filters_table_action_frame->Button(
        -text => 'clear form',
        -command => sub{
            $self->_clear_filter_form();
        },
    )->pack(-side => 'right');
    
    # -- remove filter
    $module_filters_table_action_frame->Button(
        -text => 'remove',
        -command => sub{
            $self->_filter_delete();
        },
    )->pack(-side => 'right');
    
    # -- edit filter
    $module_filters_table_action_frame->Button(
        -text => 'edit',
        -command => sub{
            $self->_filter_edit();
        },
    )->pack(-side => 'right');
    
    # -- add filter
    $module_filters_table_action_frame->Button(
        -text => 'add',
        -command => sub{
            $self->_filter_add();
        },
    )->pack(-side => 'right');
    
    return $filter_definition_frame;
} # /_build_add_edit_filter_form




=head2 _build_workspace_area( $parent )

Builds the GUI of the (main) workspace area.

=cut

sub _build_workspace_area {
    my $self = shift;
    my $parent = shift or die('Missing parent frame');
    
    my $image = $self->cpanmini_execution_animation;
    
    $parent->Button(
        -text => 'Create / update CPAN mirror',
        -command => sub{
            $self->cpanmini_execution_animation->start_animation();
            ${$self->minicpan_execution_request_flag} = 1;
            $self->check_status_1();
        },
        -compound => 'top',
        -image => $image,
        -bg => 'white',
        -relief => 'flat',
    )->pack;

    return;
} # /_build_workspace_area




=head2 check_status_1()

Checks for changes in the thread signals (minicpan_execution_request_flag and minicpan_execution_finished_flag).
Reflects the current state in the GUI.

Plays ping pong with check_status_2.

XXX: maybe replace Tk::after by Tk::repeat?

=cut

sub check_status_1 {
    my $self = shift;
    
	$self->mw->after(
		500,
		sub {
			if ( ${$self->minicpan_execution_finished_flag} == 1 ) {
				$self->cpanmini_execution_animation->stop_animation();

				#Reset flags
				${$self->minicpan_execution_finished_flag} = 0;
				${$self->minicpan_execution_request_flag} = 0;
				print "child_request finished\n";
			} else {
				$self->check_status_2();
				print "child_request processing\n";
			}
		}
	);
    
    return;
} # /check_status_1




=head2 check_status_2()

This is the pong of check_status_1.

=cut

sub check_status_2 {
    my $self = shift;
    
	$self->mw->after(
		500,
		sub {
			$self->check_status_1();
		}
	);
    
    return;
} # /check_status_2




=head2 _build_mirror_definition_area( $parent )

Builds the GUI of the mirror definition area.

=cut

sub _build_mirror_definition_area {
    my $self = shift;
    my $mirror_definition_frame = shift or die('Missing parent frame');
    my $mw = $self->mw;
    
    $mirror_definition_frame->gridColumnconfigure(1, -weight => 1);
    $mirror_definition_frame->gridRowconfigure(3, -weight => 1);
    
    my $cpan_remote_pic = $mw->Photo(-file => File::ShareDir::dist_file('My-MiniCPAN', '64x64/globe2.png'));
    
    $mirror_definition_frame->Label(
        -image => $cpan_remote_pic,
        -bg => 'white',
    )->grid(-row => 0, -column => 0);
    
    my $cpan_remote_frame = $mirror_definition_frame->Frame(-bg => 'white')->grid(-row => 0, -column => 1, -sticky => 'we',);
    
    # your CPAN source on the web - that's what you want to mirror:
    $cpan_remote_frame->Label(
        -text => "Remote:",
        -anchor => 'w',
        -bg => 'white',
    )->pack(-fill => 'x',);
    
    my $mirror_def_entry = $cpan_remote_frame->Entry(
        -bg => 'white',
        -textvariable => $self->cpan_mirror_remote,
    )->pack(-fill => 'x');
    
    $cpan_remote_frame->Label(
        -anchor => 'w',
        -bg => 'white',
        -text => 'e.g. http://artfiles.org/cpan.org/ ',
    )->pack(-fill => 'x');
    
    my $cpan_sites_hint_frame = $cpan_remote_frame->Frame(
        -bg => 'white',
    )->pack(-fill => 'x');
    
    #$cpan_sites_hint_frame->Label(
    #    -text => "Note: You can find a mirror here: www.cpan.org/SITES.html",
    #    -anchor => 'w',
    #    -bg => 'white',
    #)->pack(-fill => 'x',);
    
    my $cpan_sites_hint_rotext = $cpan_sites_hint_frame->ROText(
        -width => 30,
        -height => 1,
    )->pack(-fill => 'x',);
    
    $cpan_sites_hint_rotext->insert("end", "Note: You can find a mirror here: www.cpan.org/SITES.html");
    
    
    # row in the middle
    
    my $cpan_download_pic = $mw->Photo(-file => File::ShareDir::dist_file('My-MiniCPAN', '48x48/arrow-down-3.png'));
    
    $mirror_definition_frame->Label(
        -image => $cpan_download_pic,
        -bg => 'white',
    )->grid(-row => 1, -column => 0);
    
    
    
    my $cpan_local_frame = $mirror_definition_frame->Frame(-bg => 'white')->grid(-row => 2, -column => 1, -sticky => 'nwe',);
    
    my $cpan_local_pic = $mw->Photo(-file => File::ShareDir::dist_file('My-MiniCPAN', '64x64/my_computer.png'));
    
    $mirror_definition_frame->Label(
        -image => $cpan_local_pic,
        -bg => 'white',
    )->grid(-row => 2, -column => 0);
    
    # Your local CPAN mirror location - where to store the mirrored files:
    $cpan_local_frame->Label(
        -anchor => 'w',
        -bg => 'white',
        -text => 'Local:',
    )->pack(-fill => 'x');
    my $target_def_entry = $cpan_local_frame->Entry(
        -bg => 'white',
        -textvariable => $self->cpan_mirror_local,
    )->pack(-fill => 'x');
    
    
    # -- Save and Cancel button
    my $mirror_def_action_frame = $mirror_definition_frame->Frame(
    )->grid(-row => 4, -sticky => 's',);
    #pack(-fill => 'x', -side => 'bottom',);
    
    $mirror_def_action_frame->Button(
        -text => 'Update',
        -command => sub{
            # validate input
            # TODO
            
            # store to database
            $self->write_option('remote', ${$self->cpan_mirror_remote});
            $self->write_option('local', ${$self->cpan_mirror_local});
            
            return;
        },
    )->pack(-side => 'left');
    
    $mirror_def_action_frame->Button(
        -text => 'Cancel',
        -command => sub{
            $self->show_mirror_definition();
        },
    )->pack(-side => 'left');

    return;
} # /_build_mirror_definition_area




=head2 _build_mirror_options_area( $parent )

Builds the GUI of the mirror options area.

=cut

sub _build_mirror_options_area {
    my $self = shift;
    my $mirror_options_frame = shift or die('Missing parent frame');
    
    my $mirror_options_padframe = $mirror_options_frame->Frame(-bg => 'white')->pack(-fill => 'both', -expand => 1);#->grid(-row => 0, -column => 0, -sticky => 'nswe');
    
    
    # dirmode    
    my $opt_dirmode = $mirror_options_padframe->Labelframe(
        -bg => 'white',
        -text => 'dirmode',
    )->pack(-fill => 'x', -padx => 1,);
    $opt_dirmode->gridColumnconfigure(0, -minsize => 28);
    $opt_dirmode->gridColumnconfigure(1, -weight => 1);
    $opt_dirmode->gridRowconfigure(2, -weight => 1);
    my $opt_dirmode_entry = $opt_dirmode->LabEntry(
        -label => 'dirmode: ',
        -labelPack    => [-side => 'left', -anchor => 'w',],
        -text => '0711',
        -justify => 'left',
        -bg => 'white',
    )->grid(-row => 0, -column => 1, -sticky => 'w'),;
 
    $opt_dirmode->Label(
        -text => 'Generally an octal number, this option sets the permissions of created directories. It defaults to 0711.',
        -justify => 'left',
        -bg => 'white',
    )->grid(-row => 1, -column => 1, -sticky => 'w',);
    
    if( $^O eq 'MSWin32' ) {
        $opt_dirmode_entry->configure(-state => 'disabled');
        $opt_dirmode->Label(
            -text => 'Does not apply on Windows.',
            -justify => 'left',
            -bg => 'white',
        )->grid(-row => 2, -column => 1, -sticky => 'w',);
    }
    
    
    # exact_mirror
    $self->_build_bool_option(
        parent      => $mirror_options_padframe,
        variable    => $self->option_exact_mirror,
        option_name => 'exact_mirror',
        text        => 'If true, the files_allowed method will allow all extra files to be mirrored.',
    )->pack(-fill => 'x', -padx => 1,);
    
    
    # ignore_source_control
    $self->_build_bool_option(
        parent      => $mirror_options_padframe,
        variable    => $self->option_ignore_source_control,
        option_name => 'ignore_source_control',
        text        => 'If true, CPAN::Mini will not try to remove source control files during cleanup.',
    )->pack(-fill => 'x', -padx => 1,);
    
    
    # force
    $self->_build_bool_option(
        parent      => $mirror_options_padframe,
        variable    => $self->option_force,
        option_name => 'force',
        text        => 'If true, this option will cause CPAN::Mini to read the entire module list and update anything out of date,' . "\n"
                        . 'even if the module list itself wasn\'t out of date on this run.',
    )->pack(-fill => 'x', -padx => 1,);
    
    
    # skip_perl
    $self->_build_bool_option(
        parent      => $mirror_options_padframe,
        variable    => $self->option_skip_perl,
        option_name => 'skip_perl',
        text        => 'If true, CPAN::Mini will skip the major language distributions: perl, parrot, and ponie.' . "\n"
                        . 'It will also skip embperl, sybperl, bioperl, and kurila.',
    )->pack(-fill => 'x', -padx => 1,);
    
    
    # log level
    # TODO, but unless we're showing the output, it's not really required.
    
    
    # errors
    $self->_build_bool_option(
        parent      => $mirror_options_padframe,
        variable    => $self->option_errors,
        option_name => 'errors',
        text        => 'If true, CPAN::Mini will warn with status messages on errors. (default: true)',
    )->pack(-fill => 'x', -padx => 1,);
    
    
    # offline
    $self->_build_bool_option(
        parent      => $mirror_options_padframe,
        variable    => $self->option_offline,
        option_name => 'offline',
        text        => 'If offline, CPAN::Mini will not attempt to contact remote resources.',
    )->pack(-fill => 'x', -padx => 1,);
    
    
    # no_conn_cache
    $self->_build_bool_option(
        parent      => $mirror_options_padframe,
        variable    => $self->option_no_conn_cache,
        option_name => 'no_conn_cache',
        text        => 'This is mostly useful as a workaround for connection cache failures.',
    )->pack(-fill => 'x', -padx => 1,);
    
    return;
} # /_build_mirror_options_area




=head2 _build_module_filter_area( $parent )

Builds the GUI of the module filter area.

=cut

sub _build_module_filter_area {
    my $self = shift;
    my $module_filter_outer_frame = shift or die('Missing parent frame');
    
    my $module_filter_frame = $module_filter_outer_frame->Labelframe(
        -bg => 'white',
        -text => 'Configured filters',
    )->pack(-fill => 'both',);
    
    $module_filter_frame->Label(
        -text => "You can configure filtes for either a path or a module. "
            . "If a distribution matches one of the patterns, it will not be mirrored.\n"
            . "Path filter: A regex rule is matched if the path matches the regex.\n"
            . "Module filter: like path filter but the pattern is only applied to the module name.",
        #-wraplength => 500,
        -anchor => 'w',
        -justify => 'left',
        -bg => 'white',
    )->pack(-fill => 'x', -padx => 3,);
    
    # -- Filter list
    my $hlist = $module_filter_frame->Scrolled(
        'Treeplus',
        -scrollbars => 'osoe',
        -columns => 3,
        -header => 1,
        -bg => 'white',
    )->pack(-fill => 'both', -expand => 1, -padx => 3);
    $self->module_filter_hlist($hlist);
    $hlist->bind('<Delete>', sub{ $self->_filter_delete(); });
    
    $hlist->configure(
        -browsecmd => sub{
            # fill the form fields
            my ($selected_filter) = $hlist->info('selection');
            my $filter_id = $hlist->info('data', $selected_filter);
            my $rs = $self->schema->resultset('ModuleFilter')->find($filter_id);
            $self->filter_add_edit_form_type($rs->filter_type_id);
            $self->filter_add_edit_form_pattern($rs->pattern);
            $self->filter_add_edit_form_comment($rs->comment);
        },
    );
    
    $hlist->headerCreate(0,
        -itemtype           => 'advancedheader',
        -text               => 'Filter Type',
        -activeforeground   => 'white',
        -resize_column      => 1,
        -is_primary_column  => 0,
    );
    
    $hlist->headerCreate(1,
        -itemtype           => 'advancedheader',
        -text               => 'Pattern',
        -activeforeground   => 'white',
        -resize_column      => 1,
        -is_primary_column  => 1,
    );
    
    $hlist->headerCreate(2,
        -itemtype           => 'advancedheader',
        -text               => 'Comment',
        -activeforeground   => 'white',
        -resize_column => 1,
    );
    
    $hlist->columnWidth(0, 84);
    $hlist->columnWidth(1, 200);

    
    my $last_hlist_index = 0;
    my $rs = $self->schema->resultset('ModuleFilter')->search(undef);
    while ( my $filter = $rs->next ) {
        $last_hlist_index++;
        $hlist->add($last_hlist_index, -data => $filter->id);
        $hlist->item('create',$last_hlist_index, 0, -text => $filter->filter_type->type);
        $hlist->item('create',$last_hlist_index, 1, -text => $filter->pattern);
        $hlist->item('create',$last_hlist_index, 2, -text => $filter->comment);
    }
    
    # -- filter actions
    
    my $module_filters_table_action_frame = $module_filter_outer_frame->Frame(-bg => 'white')->pack(-fill => 'x',);
    my $filter_add_edit_form = $self->_build_add_edit_filter_form($module_filters_table_action_frame);
    $filter_add_edit_form->pack(-fill => 'x');
    
    return;
} # /_build_module_filter_area




=head2 _rgb2hex( $red, $green, $blue )

Converts RGB color to HEX color.

=cut

sub _rgb2hex {
    my $self = shift;
    my @rgb = @_;
    
    my $hex = '#' . $self->rgb->rgb2hex(@rgb);
    
    return $hex;
} # /_rgb2hex




=head2 _filter_add()

Checks for valid input and creates a new filter.
Updates database and HList.

TODO: check if new entry already exists

TODO: check why there is always 2 sort indicators when the application starts

=cut

sub _filter_add {
    my $self = shift;
    
    if ( ${$self->filter_add_edit_form_pattern} eq '' ) {
        $self->mw->messageBox(
            -icon => 'error',
            -title => 'Error adding filter',
            -message => 'Please specify a pattern.',
            -type => 'Ok',
        );
        return;
    }
    
    # update database
    # TODO: error handling
    my $rs = $self->schema->resultset('ModuleFilter')->create({
        filter_type_id  => ${$self->filter_add_edit_form_type},
        pattern         => ${$self->filter_add_edit_form_pattern},
        comment         => ${$self->filter_add_edit_form_comment},
    });
    
    # update HList
    my $hlist = $self->module_filter_hlist;
    my $last_hlist_index = ($hlist->info('children'));
    $last_hlist_index++; # new row
    
    $hlist->add($last_hlist_index, -data => $rs->id);
    $hlist->item('create',$last_hlist_index, 0, -text => $rs->filter_type->type);
    $hlist->item('create',$last_hlist_index, 1, -text => $rs->pattern);
    $hlist->item('create',$last_hlist_index, 2, -text => $rs->comment);
    
    # reset form fields
    $self->_clear_filter_form;
    
    #$hlist->initSort();
    
    return;
} # /_filter_add




=head2 _filter_delete()

Deletes the selected filter.

=cut

sub _filter_delete {
    my $self = shift;
    my $hlist = $self->module_filter_hlist;
    
    my ($selected_filter) = $hlist->info('selection');
    
    if ( !$selected_filter ) {
         $self->mw->messageBox(
            -icon => 'error',
            -title => 'Error deleting filter',
            -message => 'Please select a filter from the table',
            -type => 'Ok',
        );
         return;
    }
    
    my $filter_id = $hlist->info('data', $selected_filter);
    my $rs = $self->schema->resultset('ModuleFilter')->find($filter_id);
    $rs->delete;
    
    $hlist->delete('entry', $selected_filter);
    
    $self->_clear_filter_form;
    
    return;
} # /_filter_delete




=head2 _clear_filter_form()

Resets filter definition form fields.

=cut

sub _clear_filter_form {
    my $self = shift;
    
    $self->filter_add_edit_form_type(1);
    $self->filter_add_edit_form_pattern('');
    $self->filter_add_edit_form_comment('');
    
    my $hlist = $self->module_filter_hlist;
    $hlist->selectionClear;
    $hlist->anchorClear;
    
    return;
} # /_clear_filter_form




=head2 _filter_edit()

Applies the changes of the filter form to the selected entry.

=cut

sub _filter_edit {
    my $self = shift;
    my $hlist = $self->module_filter_hlist;
    
    my ($selected_filter) = $hlist->info('selection');
    if ( !$selected_filter ) {
        $self->mw->messageBox(
            -icon => 'error',
            -title => 'No filter selected',
            -message => 'Please select a filter first',
            -type => 'Ok',
        );
        return;
    }
    
    
    my $filter_id = $hlist->info('data', $selected_filter);
    my $rs = $self->schema->resultset('ModuleFilter')->find($filter_id);
    
    $rs->update({
        filter_type_id  => ${$self->filter_add_edit_form_type},
        pattern         => ${$self->filter_add_edit_form_pattern},
        comment         => ${$self->filter_add_edit_form_comment},
    });

    $hlist->item('configure',$selected_filter, 0, -text => $rs->filter_type->type);
    $hlist->item('configure',$selected_filter, 1, -text => $rs->pattern);
    $hlist->item('configure',$selected_filter, 2, -text => $rs->comment);
    
    #$hlist->initSort();
    
    return;
} # /_filter_edit




# see Moose/Manual/BestPractices
__PACKAGE__->meta->make_immutable;


=head1 SEE ALSO

There is also a command line utility that does the same work: L<minicpan>.

See L<http://www.cpan.org/SITES.html> for a list of sites that can be used as source of your CPAN mirror.

Please feel free to provide constuctive feedback.

You can report bugs on L<Github|https://github.com/asb-capfan/MiniCPAN/issues>.

If you have a web site set up for your module, mention it here.


=head1 AUTHOR

Alexander Becker, E<lt>asb@cpan.orgE<gt>

=head1 COPYRIGHT AND LICENSE

Copyright (C) 2014 by Alexander Becker

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.20.0 or,
at your option, any later version of Perl 5 you may have available.

This package includes icons from the L<Open Icon Library|http://sourceforge.net/projects/openiconlibrary/>.
The icons are under various free/open licenses 
such as GPL, Creative Commons, etc. All sources with 
their respective licenses are documented in the
LICENSES-open-icon-library file, as well as in their metadata. 

=cut

1; # /My::MiniCPAN